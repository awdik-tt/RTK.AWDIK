# DungeonMini — Промежуточная аттестация

**Формат:** индивидуальная работа  
**Язык/среда:** Java 17+, консольное приложение, **без Maven** 
**Цель:** на практике применить изученные темы курса
---
## 0) Запуск проекта

Linux/macOS:
```bash
./build.sh
./run.sh
```

Windows:
```
build.bat
run.bat
```

---

## 1) Что уже есть в шаблоне

- Каркас игры: `Game.java` с циклом ввода и заглушками команд (`TODO`).
- Модель данных: `Player`, `Monster`, `Item`, `Room` и т.д.
- Чтение команд пользователя, обработка ошибок, базовые команды (`look`, `save`, `load`, `exit`).
- Примеры I/O с try-with-resources (`SaveLoad`).

---

## 2) Задачи студента

### Реализовать команды
1. **move `<north|south|east|west>`**
   - Перемещение между комнатами.
   - Если нет пути — выбросить `InvalidCommandException`.

2. **take `<item name>`**
   - Взять предмет из комнаты и положить в инвентарь.

3. **inventory**
   - Вывести инвентарь с использованием **Stream API**: сортировка и группировка по типу предмета.

4. **use `<item name>`**
   - Применить предмет (полиморфизм через `Item.apply()`).

5. **fight**
   - Простая пошаговая битва с монстром, уменьшение HP, выпадение лута, завершение игры при смерти игрока.

### Использовать try-with-resources
- Реализовать сохранение/загрузку состояния (минимум — игрок и инвентарь).

### Показать работу GC
- Команда `gc-stats` выводит `used/free/total` память из `Runtime`.

### Обработать исключения
- Все некорректные ситуации — через `InvalidCommandException` с понятным текстом.
- Покажите в комментариях различие ошибок компиляции (пример закомментированного кода) и ошибок выполнения (пример `ArithmeticException`).

---

## 3) Примеры команд

```text
> look
Площадь: Каменная площадь с фонтаном.
Выходы: north

> move north
Вы перешли в: Лес
Лес: Шелест листвы и птичий щебет.
Предметы: Малое зелье
В комнате монстр: Волк (ур. 1)
Выходы: south, east

> take Малое зелье
Взято: Малое зелье

> inventory
- Potion (1): Малое зелье

> use Малое зелье
Выпито зелье: +5 HP. Текущее HP: 25

> fight
Вы бьёте Волк на 5. HP монстра: 3
Монстр отвечает на 1. Ваше HP: 24
```

---

## 4) Критерии оценивания (100 баллов)

| Блок                       | Баллы |
|----------------------------|-------|
| Реализация команд          | 50    |
| Обработка исключений       | 10    |
| Stream API и коллекции     | 15    |
| I/O + try-with-resources   | 10    |
| GC                         | 10    |
| Чистота кода, инкапсуляция | 5     |

---

## 5) Минимальный сценарий для самопроверки

- Запустите игру.
- Посмотрите стартовую комнату (`look`).
- Перейдите в лес (`move north`).
- Возьмите зелье (`take ...`).
- Выведите инвентарь (`inventory`).
- Используйте предмет (`use ...`).
- Победите монстра (`fight` несколько раз).
- Сохраните и загрузите игру (`save` / `load`).
- Проверьте `about` и `gc-stats`.

---

## 6) Дополнительно (+ баллы)

- Сериализация состояния всех комнат.
- Добавление новой комнаты, двери и логики использования ключа.
- Таблица лидеров (`scores.csv`) с сохранением очков при выходе.
- Команда `alloc` + демонстрация GC.

## 7) описание реализации программы

### Архитектура приложения

Проект реализован по модульной архитектуре и разделён на следующие пакеты:

1. **`com.example.dungeon`** - содержит точку входа в приложение
   - `Main.java` - главный класс с методом `main`, запускающий игру

2. **`com.example.dungeon.core`** - ядро приложения, реализующее игровую логику
   - `Game.java` - основной класс игры, управляющий игровым циклом, командами и состоянием игры
   - `Command.java` - функциональный интерфейс для команд
   - `InvalidCommandException.java` - исключение для некорректных команд
   - `SaveLoad.java` - класс для сохранения и загрузки состояния игры
   - `WorldInfo.java` - вспомогательный класс для отслеживания инициализации

3. **`com.example.dungeon.model`** - модельные классы, представляющие игровые сущности
   - `GameState.java` - состояние игры (игрок, текущая комната, счёт)
   - `Entity.java` - абстрактный класс для игровых сущностей
   - `Player.java` - класс игрока
   - `Monster.java` - класс монстра
   - `Room.java` - класс комнаты
   - `Item.java` - абстрактный класс предмета
   - `Potion.java`, `Weapon.java`, `Key.java` - конкретные реализации предметов
   - `Door.java` - класс двери

### Особенности реализации

#### Игровой цикл
Класс `Game` реализует основной цикл игры с использованием `try-with-resources` для автоматического закрытия потока ввода. Игра принимает команды от пользователя в формате:
- `команда [аргументы]`

#### Команды
Команды реализованы через `Map<String, Command>`, где ключ - название команды, значение - лямбда-выражение, реализующее логику команды. Все команды обрабатывают контекст `GameState` и список аргументов.

Реализованные команды:
- `help` - вывод списка команд
- `about` - информация о разработчике и версии
- `gc-stats` - статистика по использованию памяти и работе GC
- `alloc` - выделение памяти для демонстрации GC
- `look` - описание текущей комнаты
- `move <direction>` - перемещение между комнатами
- `take <item>` - взятие предмета
- `inventory` - вывод инвентаря с использованием Stream API
- `use <item>` - применение предмета (полиморфизм)
- `fight` - бой с монстром
- `save` / `load` - сохранение и загрузка игры
- `scores` - таблица лидеров
- `exit` - выход из игры

#### Модель данных
- Использована иерархия классов: `Entity` → `Player` / `Monster`
- Абстрактный класс `Item` с наследниками `Potion`, `Weapon`, `Key` для демонстрации полиморфизма
- Класс `Room` содержит информацию о предметах, монстрах, соседних комнатах и дверях
- Класс `GameState` хранит полное состояние игры для целей сохранения/загрузки

#### Сохранение и загрузка
Класс `SaveLoad` реализует сериализацию состояния игры в текстовый файл с использованием `try-with-resources`. Сохраняются:
- Информация об игроке (имя, здоровье, атака)
- Инвентарь игрока
- Текущая комната
- Все комнаты с описанием, предметами, монстрами и дверями

#### Обработка ошибок
Все ошибки обрабатываются через `InvalidCommandException`, что позволяет централизованно обрабатывать некорректный ввод пользователя.

#### Stream API
Команда `inventory` использует Stream API для группировки и сортировки предметов в инвентаре по типам:
```java
Map<String, List<Item>> groupedItems = inventory.stream()
    .collect(Collectors.groupingBy(item -> item.getClass().getSimpleName()));
```

#### Демонстрация GC
Команда `alloc` выделяет большой объем памяти для демонстрации работы сборщика мусора, а команда `gc-stats` выводит информацию об использовании памяти.

#### Дополнительная функциональность
- Реализована система дверей и ключей
- Добавлена таблица лидеров в файл `scores.csv`
